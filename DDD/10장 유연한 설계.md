
### 선언적 설계
---

> assertion을 이용하면 더 나은 설계를 만들 수 있으나,
> 사람이 작성하기 때문에 실제로 이를 보장하는 방법은 있을수가 없다.


assertion을 위회하는 case

```java
public class BankAccount {
    private double balance;
    private TransactionLogger logger;

    public void withdraw(double amount) {
        assert amount > 0 : "출금액은 0보다 커야 합니다.";
        assert balance >= amount : "잔액이 부족합니다.";

        balance -= amount;
        logger.log(amount);

        if (amount > 1000) {
            applyLargeWithdrawalFee(); // 숨겨진 부수효과
        }
    }

    private void applyLargeWithdrawalFee() {
        balance -= 10; // ASSERTION을 우회하는 잔액 변경
    }
}
```

위와 같이 assertion을 우회 하는 Case가 충분히 생길 수 있음.

>개념적인 상호작용에 따른 부수효과를 포함하는 프로시저(procedure)를 작성하게 된다.

도메인 모델 간의 상호작용하는 프로시저, 메서드를 만들게 되는데 매서드를 실행하는 과정에서 도메인 모델 객체에 대한 상태값을 업데이트 해버리는 부수효과를 포함할 수 있음.

>전통적인 객체 지향 프로그램에 형식적인 정밀함을 부여하지 못한다.

도메인을 잘 나타내고, 동작자체가 예측가능하고 명확하고, 불변식을 보장하고 부수효과가 거의 없는것을 정밀함 이라는 단어로 표현한 것 같음.


>선언적 설계란
>실행 가능한 명세 로서 프로그램 전체 혹은 프로그램의 일부를 작성하는 방식을 의미한다.
>특성(properties)을 매우 정확하게 기술함으로써 소프트웨어를 제어하는 것이다.


```java
@NotNull 
@Size(min = 2, max = 30) 
private String username;
```

```java
@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Email
    @Column(unique = true)
    private String email;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    private List<Order> orders;
}
```

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
    password: password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  cache:
    type: redis
server:
  port: 8080
```

필드 특성을 정확하게 기술함으로서 제어하는 예제가 될수 있지 않을까?

>[!Note]
>에릭 에반스가 말하는 선언적 설계는 
>사람이 작성하는 것이기 때문에 생기는 부수효과들이 정교함을 더해주지 못하니,
>프로그램의 동작을 명령형으로 상세히 기술하는 대신, 
>원하는 결과나 조건을 선언하는 방식으로 소프트웨어를 설계하는 접근 이지 않나. 

>필요한 모든 것을 충분하게 표현할 수 없는 선언 언어 (declaration language)와 자동화로 감
>당할 수 있는 범위를 벗어나면 소프트웨어를 확장 하기가 어려운 프레임 워크
>자동으로 생성된 코드와 직접 작성한 코드를 통합한 후 코드를 다시 생성할 경우 통합된
>부분이 없어져서 반복적인 주기를 무력하게 만드는 코드 생성 기법

선언적으로 표현하는 것이 도메인 로직을 표현하는데 한계가 존재하거나,
도메인 로직 특성상 자동화로 코드 구현이 감당하기 힘든 프레임 워크 적인 한계가 존재할 때.

자동으로 코드 생성이 되었는데 수정을 하고나서 다시 코드 생성시 수정된 부분이 날아가는 케이스.

>개발자들은 프레임워크의 한계에 갇힌 채 뭔가를 인도하기 위해 설계에서 우선적으로 처리해야 할 문제를 위주로 프로세스를 재편하게 된다.

프레임워크가 제공하는 기능적 한계에 사고가 갇힌 채,
도메인적 심층모델에 대한 한계점을 극복하는 것이아닌 선언적 설계 에서 우선적으로 처리하면 좋아 보이는 문제를 위주로 프로세스를 재편하게 됨.

>모델을 개선하려면 개발자가 언어를 수정할 수 있어야 한다.
>언어를 수정하려면 기반 클래스 라이브러리뿐 아니라 문법을 선언하는 방식과 언어를 번역할 때의 특징까지도 변경해야 할지 모른다.

객체 지향의 단점.
1. 모델 변경시 도메인 언어 자체를 수정해야 할 수 있을수도 있음.
2. 모델과 도메인 특화 언어가 변경될 때 기존 클라이언트 코드를 새로운 모델에 맞게 수정하기 어려 울 수 있음.

도메인 모델의 변경이 광범위한 코드 수정을 필요로 하며, 이는 시간이 많이 걸리고 오류가 발생하기 쉬운 과정일 수 있음

>인적으로 고급 기술과 설계 개념을 배우는 것을 매우 즐기지만 미래에 설계를 담당할 유지보수 팀의 기술뿐 아니라 특정 팀의 기술도 냉정하게 평가해야 한다.


현재 개발 팀이 복잡한 도메인 관련 언어이나 선언적 설계를 효과적으로 사용할 수 있는지 평가해야 하고 추후 미래의 유지보수 팀이 이해하고 관리할 수 있는 수준의 복잡성을 유지해야 한다고 이해 해보았다.

```scheme
(define-syntax define-entity
  (syntax-rules ()
    ((define-entity name (field ...))
     (define (name field ...)
       (list 'name (list 'field field) ...)))))

(define-entity person (name age))
(define john (person "John" 30))

```

매크로를 활용해서 person 을 확장 가능함.

```scheme
(define-syntax define-specification
  (syntax-rules ()
    ((define-specification name predicate)
     (define (name obj)
       (and (procedure? obj)
            (predicate obj)))))) 

(define-specification large-order?
  (lambda (order)
    (> ((order 'total)) 100)))

(define-specification rush-order?
  (lambda (order)
    (eq? ((order 'get) 'priority) 'rush)))

(define-syntax and-specification
  (syntax-rules ()
    ((and-specification spec1 spec2)
     (lambda (obj)
       (and (spec1 obj) (spec2 obj))))))

(define large-rush-order?
  (and-specification large-order? rush-order?))

; 사용 예
(define order2 (Order 2))
((order2 'add-item) '("Laptop" 1000))
((order2 'set! 'priority) 'rush)

(large-rush-order? order2)  ; #t
```

이런식으로 도메인 자체의 비즈니스 로직을 표현할수 있다 라는것 같은데..
사용 예를 보면 도메인 언어가 보다더 직관적인것 같기도하고 아닌것 같기도하고 잘 모르겠음.

